# UnorderedFileIndex
题目描述——设计一个高效的索引结构<br>
某个机器的配置为：CPU 8 cores，MEM 4G，HDD 4T。这个机器上有一个1T的无序数据文件，格式为(key_size:uint64, key:bytes, value_size:uint64_t, value:bytes)，其中1B<=key_size<=1KB，1B<=value_size<=1MB。设计一个索引结构，使得并发随机地读取每一个key-value的代价最小，不需要支持range scan。允许对数据文件做任意预处理，但是预处理的时间计入到整个读取的代价里。

主要思路
1)	不需要支持范围查询，索引选择哈希表；
2)	将1T的数据文件mmap到内存中，不需要read系统调用，以及内核态到用户态的数据拷贝；
3)	由于内存中无法全部缓存索引文件，采用将一个临时大文件mmap到内存中，作为索引的内存空间来源，可以直接采用内存的换入换出机制，简化缓存淘汰策略。索引脏内存换出到磁盘时需要写操作，粒度4KB，索引文件在设计时考虑尽可能少的占用内存空间，从而尽可能少的写磁盘；
4)	创建线程池，抽象索引读写任务，利用8核CPU进行并发读写。

key-value数目评估<br>
最坏情况：单个key占用1B(1B只能表示256个key，这里为了评估内存占用而简化)，value占用1B，key-value占用22B，1T文件中包含的key-value个数约50G个；<br>
最好情况：value占用1M，1T文件中包含的key-value个数约1M个；<br>
平均情况：key-value占用0.5M，1T文件中包含的key-value个数约2M个。<br>

已完成的功能<br>
索引表设计(对应MappingTable.h/c)
1) 哈希桶设计：每个哈希桶作为冲突链表头结点，使用单链表，占用8B。插入时，插入到链表头部，使用CAS支持并发插入。2GB内存作为哈希桶内存占用，共256M个哈希桶。采用开源的xxhash源码计算key的8B哈希值。
2) 哈希Entry设计<br>
2.1) 当key_size<=6B，并且value_size<=8B，key-value直接存储在哈希表中，优化小key小value下索引表读性能；<br>
2.2) 当key_size<=6B，并且value_size>8B，key直接存在哈希表中，同时只存储value在file上的地址，优化大value下索引表空间占用；<br>
2.3) 当key_size>6B时，只存储key的哈希值(只取哈希值的低6B)，以及key-value在file上的地址。哈希值相等时，需要比较key来确定。6B哈希值可以表示2^48个数，远大于最大50G个key-value数，可以认为计算出来相同哈希值的概率极低，极大概率上哈希值相等时key也相等；<br>
2.4) 单链表组织冲突链，每个Entry占用24B。
3) 哈希表内存管理：最大内存占用2G(哈希桶)+50G(最大key-value数目)*24=1202G。创建一个1.3T的临时文件并映射到内存中，作为哈希表的内存来源。前面2G作为哈希桶空间，后面约1.3T的空间采用Log形式追加分配Entry，由于页缓存的存在，该处空间只会被写一次。优化：哈希桶空间常驻内存，否则哈希桶中的值经常被修改，换入换出时造成写放大很大，未完成。

数据文件读写控制设计(对应FileCtrl.h/c)<br>
1) 将1T数据文件映射到内存，简化读写调用，以及内核态到用户态的数据拷贝。<br>
2) 提供多线程遍历的功能。<br>

线程池设计(对应ITask.h, ThreadPool.h/c)<br>
1) 创建包含8个线程的线程池作为消费者，以任务作为执行单元。<br>
2) 对任务的Run函数进行抽象，每一种任务各自实现自己的Run函数，在线程中执行，Run函数执行完后调用callback函数回调通知调用方。<br>
3) 线程池支持添加任务。优化：对线程池任务满反馈生产者功能未完成。<br>

未完成的功能
预处理<br>
1) 创建8个构建索引任务，调用FileCtrl提供的遍历接口获取到一条key-value，并调用MappingTable提供的Put接口；<br>
2) callback函数中通知某个任务构建完成；<br>
3) 添加构建索引任务到线程池中，并发构建索引；<br>
4) 等待构建索引任务完成。<br>

实现对外提供的Get功能<br>
1) 创建查询任务，扔到线程池中，并用信号量阻塞自己；
2) 在callback函数中用信号量通知查询完成，返回用户数据。
